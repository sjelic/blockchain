<!DOCTYPE html>
<html lang="en">
<head>
    <title></title>
    <link rel="icon" type="image/png" href="#">
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous"> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.7.3/web3.min.js" integrity="sha512-Ws+qbaGHSFw2Zc1e7XRpvW+kySrhmPLFYTyQ95mxAkss0sshj6ObdNP3HDWcwTs8zBJ60KpynKZywk0R8tG1GA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->
    <link href="./public/bootstrap-5.0.2.min.css" rel="stylesheet">
    <script src="./public/web3-1.7.3.min.js" referrerpolicy="no-referrer"></script>
</head>
<body class="p-4">
    <div class="row mb-5">
        <div class="col-md-6">
            <div class="card network-info">
                <div class="card-header">
                    Network Details
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-sm-4">Status</div>
                        <div class="col-sm-8"><span id="status">not connected</span></div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">User Wallet</div>
                        <div class="col-sm-8"><span id="user-wallet">N/A</span></div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">Network ID</div>
                        <div class="col-sm-8"><span id="network-id">N/A</span></div>
                    </div>
                    <!--<div class="row">
                        <div class="col-sm-4">Gas Limit</div>
                        <div class="col-sm-8"><span id="gas-limit">N/A</span></div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">Gas Price</div>
                        <div class="col-sm-8"><span id="gas-price">N/A</span></div>
                    </div>-->
                </div>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card wallet-custom">
                <div class="card-header">Wallet</div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Address</label>
                        <!--<input type="text" class="form-control" id="user-wallet-address" placeholder="0x...">-->
                        <select name="user-wallet-address" id="user-wallet-address">
                            <optgroup label="Administrator account">
                                <option value="0x6874372571Fe6af2C762E2792Ab7A6a5660Ce5b1">Administrator</option>
                            </optgroup>
                            <optgroup label="Ships">
                                <option value="0xF640e63C0afa0092a871CE31EB21F0c29455F284">Vessel A</option>
                                <option value="0xa2B365bB5513c179956781e205e60785BACFd2AB">Vessel B</option>
                           
                            </optgroup>
                            <optgroup label="Suppliers">
                                <option value="0x240495bfCb8A3699d2A572CbBAd3060D9192642c">Supplier A</option>
                                <option value="0x80844A2d71Fb3290a00Ea1Bd10005E1B146458cC">Supplier B</option>
                                <option value="0xe807E60E88EA25Dc33E95B10abE87776Df433464">Supplier C</option>
                                <option value="0x7B7Ac3f926e3aC69f007fB895CB36DcFF30eaC32">Supplier D</option>
                                <option value="0x05072aD256227809e9A95BB4CC413782B1785951">Supplier E</option>
                            </optgroup>
                            <optgroup label="Port authorities">
                                <option value="0xfaF256a30fb5055AF08c80e6bb6565B079E0138C">Krishnapatnam</option>
                                <option value="0x29AcA5eDCCa695502EcbE58074A821237048E07F">Fujairah</option>
                                <option value="0xFb939EbCdf792edC0cdbAC975eDdc33032Ec18E5">Mina Zayed</option>
                                <option value="0x6150a13e6D09610EeefaCE1C48BB4a18781ac9fe">Khalifa</option>
                                <option value="0x51A8a497Dedf5b532bc66dc0Cb1F646e8afaE8A2">Aqaba</option>
                                <option vlaue="0x717debAeD9592322Ec1a2a0Fb58e82210a271B39">Suez</option>
                                <option value="0x01e2529d58CDebFc0457444EFF01b63b68aC08ef">Algeciras</option>
                                <option value="0x59c16CD8e558e5d78e583B8e67cb74a7c885C7a7">Baltimore</option>
                                <option value="0xD4470cf8F6e119cb8e8D21D5b4D627d70aACae28">Houston</option>
                                <option value="0xd483a5B66dA32D8C2B33175b4d96b95985E94064">Gibraltar</option>
                                <option value="0xCB46E6eE7F4dB0c965fF67FC68ED2E0AfB879eB2">Tarragona</option>
                                <option value="0x64F3BfB9Eb2643A11177B6128D5499648f9f6c20">Rostock</option>
                                <option value="0x4faC3E4d25416f5C792a62e1b2E39BFfddf1F602">Matadi<option>
                                <option value="0x70B4791569848A9660faA072c16273012469e039">Saldanha Bay</option>
                                <option value="0x0510eC9EFC113b16679624727BCcdF78f73cd831">Las Palmas</option>
                                <option value="0x531cC7007e67cb8bf4E847593144227Da76f5e7b">Antwerp</option>
                                <option value="0x99bf248fa9E2034F80D693d6b3e6C2eFC92c590d">Messina</option>
                                <option value="0x8253A89306541B6F66f4c43790a7F8Ca25cAb571">Constanta</option>
                                <option value="0x837E6f19A2cEC65Ad9C8062D0738e17EDeC57144">Colombo</option>
                                <option value="0x138955db8625a12Cc3F4e2a17f783d4C3bce6524">Yantai</option>
                                <option value="0x8D6BE2CDdf0C99Bbb3359eD61274272D048A4860">Singapore</option>
                                <option value="0xc6937f815Faad957e5A734a91b1C463bAF449963">Beira</option>
                                <option value="0xFCbc7CeBf79Cd0A5CA57803ee17CF2Dc5248749E">Dar es Salaam</option>
                                <option value="0xa766b687fB3a366b7406848dd58eD0d5316F6490">Nacala</option>
                                <option value="0xE4F5841a786614A9955c7408fb4a38897D29f23e">Port Elizabeth</option>
                                <option value="0x4E1FAa3e895227845Cd8cF90Dd510Ec534f3A2DA">Tema</option>
                                <option value="0xE11529d94914Da33351945B1571236116ABEd15A">Praia Mole</option>
                                <option value="0x832977e9Fe80e287cad27Dd35BB63883ea76049f">Gemlik</option>
                                <option value="0xd8BFC16Fe52978227efd82017f7dD0B7f017cb97">Yalova</option>
                                <option value="0x0a316f1fc4fB8A591817CF3eB89B3180b9bB2053">Malta</option>
                                <option value="0x3f2375e5c4E87aDbAc92c6FCe14A2DB869890860">Gabes</option>
                                <option value="0x9F168D1c147CE0FB42952a493Aa05BF16aE5b329">Port Said</option>
                                <option value="0x467F87cBbE618d4ab104B21E496C1c4BF9F927F9">Chittagong</option>
                                <option value="0x03c5E04c033CcBe21aD730FC258A37Eb7b92d59f">Mongla</option>
                                <option value="0xC05bB9334364d1FCE278B4841f97534860Ddf9C3">Port Kelang</option>
                                <option value="0x6eeD70C2cca58e73649FBD8FC5e461dC487f413f">Koh Sichang</option>
                                <option value="0x9D890D9f6AB0E7f7C4a28CD4b7d9958F64D55102">Brisbane</option>
                                <option value="0x1D419F7e3fefd9cEbdB9ffC7365D90BD698311c8">Adelaide</option>
                                <option value="0x5caa9f758fa707b1f0896292a3d9a7c037b9eae5">Kandla</option>
                                <option value="0xb7b90330d47f2c172c1486a2c6c05d319c38fdc9">Jebel Ali</option>
                            </optgroup>
                            
                            
                           
                        </select>
                       
                    </div>
                    <!--<div class="mb-3">
                        <label class="form-label">Private Key</label>
                        <input type="text" class="form-control" id="user-private-key" placeholder="">
                    </div>-->
                </div>
            </div>
        </div>
    </div>

    <div id="dashboard" class="p-0 mb-5" style="display:none;">
        <ul class="nav nav-tabs" id="contracts-tab-nav">

        </ul>
        <div class="tab-content border border-top-0" id="contracts-tab-content">

        </div>
    </div>

    <div class="card text-dark bg-light mb-5 main-console">
        <div class="card-header">Console</div>
        <div class="card-body">
            <pre id="console" style="max-height: 500px;"></pre>
        </div>
    </div>

    <div class="card text-dark bg-light mb-5 main-console">
        <div class="card-header">Details</div>
        <div class="card-body">
            <pre id="smart-contract-details" style="max-height: 500px;"></pre>
        </div>
    </div>

    <div class="card text-dark bg-light mb-5 event-console">
        <div class="card-header d-flex justify-content-between">
            <span>Events</span>
            <div class="row">
                <div class="col-auto">
                    <select class="form-control form-control-sm" id="events-load-criteria">
                        <option value="load-from-block">Load from block number</option>
                        <option value="load-from-the-last-blocks" selected>Load from the last # blocks</option>
                    </select>
                </div>
                <div class="col-auto">
                    <input class="form-control form-control-sm" type="text" id="events-load-from" />
                </div>
                <div class="col-auto">
                    <button type="button" class="btn btn-primary btn-sm" id="loadBlockchainEvents">Load</button>
                </div>
            </div>
        </div>
        <div class="card-body">
            <pre id="events-console" style="max-height: 500px;"></pre>
        </div>
    </div>

<script>// ethExp is going to store the instance of the class EthereumExplorer
window.ethExp = null;

// the var contractDetailsJson is going to contain the ABI of the smart contracts.
// The placeholder below < % contract-details-json % > is going to be replace on runtime.
// Please check the function CliController@buildUI
const contractDetailsJson = [
    {
        "contractName": "SupplyChain",
        "abi": [
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "name_",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "email_",
                        "type": "string"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "id",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "supplierName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "enum Types.MaterialType",
				"name": "",
				"type": "uint8"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "qty",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "unit",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newOwnName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newOwnMail",
				"type": "string"
			}
		],
		"name": "MaterialTransfer",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "id",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "supplierName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "enum Types.MaterialType",
				"name": "mType",
				"type": "uint8"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "qty",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "unit",
				"type": "string"
			}
		],
		"name": "NewMaterial",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "shipName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "shipAddress",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "portName",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "portAddress",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "enum Types.ShipPortStatus",
				"name": "status",
				"type": "uint8"
			}
		],
		"name": "ShipStatusChanged",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "email",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "enum Types.UserType",
				"name": "userType",
				"type": "uint8"
			}
		],
		"name": "UserCreated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "name",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "email",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "enum Types.UserType",
				"name": "userType",
				"type": "uint8"
			}
		],
		"name": "UserRemoved",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "cargoId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "cargoName",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "cargoSupplierName",
				"type": "string"
			},
			{
				"internalType": "address",
				"name": "cargoSupplier",
				"type": "address"
			},
			{
				"internalType": "enum Types.MaterialType",
				"name": "cargoMType",
				"type": "uint8"
			},
			{
				"internalType": "uint256",
				"name": "cargoQty",
				"type": "uint256"
			},
			{
				"internalType": "string",
				"name": "cargoUnit",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "currentTime",
				"type": "uint256"
			}
		],
		"name": "addCargo",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "enum Types.UserType",
				"name": "uType_",
				"type": "uint8"
			},
			{
				"internalType": "address",
				"name": "userId_",
				"type": "address"
			},
			{
				"internalType": "string",
				"name": "name_",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "email_",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "country_",
				"type": "string"
			}
		],
		"name": "addNewUser",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "portId",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "status",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "currentTime",
				"type": "uint256"
			}
		],
		"name": "changeShipPortStatus",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "targetUser",
				"type": "address"
			},
			{
				"internalType": "string",
				"name": "cargoId",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "currentTime",
				"type": "uint256"
			}
		],
		"name": "trasferCargo",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "name_",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "email_",
				"type": "string"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [],
		"name": "getAllCargo",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "id",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "supplierName",
						"type": "string"
					},
					{
						"internalType": "address",
						"name": "supplier",
						"type": "address"
					},
					{
						"internalType": "enum Types.MaterialType",
						"name": "mType",
						"type": "uint8"
					},
					{
						"internalType": "uint256",
						"name": "qty",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "unit",
						"type": "string"
					}
				],
				"internalType": "struct Types.Material[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getMyCargo",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "id",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "supplierName",
						"type": "string"
					},
					{
						"internalType": "address",
						"name": "supplier",
						"type": "address"
					},
					{
						"internalType": "enum Types.MaterialType",
						"name": "mType",
						"type": "uint8"
					},
					{
						"internalType": "uint256",
						"name": "qty",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "unit",
						"type": "string"
					}
				],
				"internalType": "struct Types.Material[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getMyDetails",
		"outputs": [
			{
				"components": [
					{
						"internalType": "enum Types.UserType",
						"name": "uType",
						"type": "uint8"
					},
					{
						"internalType": "address",
						"name": "userId",
						"type": "address"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "email",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "country",
						"type": "string"
					}
				],
				"internalType": "struct Types.SpecificUser",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "id",
				"type": "address"
			}
		],
		"name": "getShipDetails",
		"outputs": [
			{
				"components": [
					{
						"internalType": "enum Types.UserType",
						"name": "uType",
						"type": "uint8"
					},
					{
						"internalType": "address",
						"name": "userId",
						"type": "address"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "email",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "country",
						"type": "string"
					}
				],
				"internalType": "struct Types.SpecificUser",
				"name": "",
				"type": "tuple"
			},
			{
				"components": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "portId",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "date",
								"type": "uint256"
							},
							{
								"internalType": "enum Types.ShipPortStatus",
								"name": "status",
								"type": "uint8"
							}
						],
						"internalType": "struct Types.ShipPort[]",
						"name": "portHistory",
						"type": "tuple[]"
					}
				],
				"internalType": "struct Types.ShipPortHistory",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "id",
				"type": "address"
			}
		],
		"name": "getShipDetailsHumanReadable",
		"outputs": [
			{
				"internalType": "string",
				"name": "ShipName",
				"type": "string"
			},
			{
				"internalType": "string[]",
				"name": "portName",
				"type": "string[]"
			},
			{
				"internalType": "uint256[]",
				"name": "portTime",
				"type": "uint256[]"
			},
			{
				"internalType": "string[]",
				"name": "portStatus",
				"type": "string[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "id",
				"type": "string"
			}
		],
		"name": "getSingleCargo",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "id",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "supplierName",
						"type": "string"
					},
					{
						"internalType": "address",
						"name": "supplier",
						"type": "address"
					},
					{
						"internalType": "enum Types.MaterialType",
						"name": "mType",
						"type": "uint8"
					},
					{
						"internalType": "uint256",
						"name": "qty",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "unit",
						"type": "string"
					}
				],
				"internalType": "struct Types.Material",
				"name": "",
				"type": "tuple"
			},
			{
				"components": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "userId",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "date",
								"type": "uint256"
							}
						],
						"internalType": "struct Types.UserHistory",
						"name": "supplier",
						"type": "tuple"
					},
					{
						"components": [
							{
								"internalType": "address",
								"name": "userId",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "date",
								"type": "uint256"
							}
						],
						"internalType": "struct Types.UserHistory[]",
						"name": "port",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "address",
								"name": "userId",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "date",
								"type": "uint256"
							}
						],
						"internalType": "struct Types.UserHistory[]",
						"name": "ship",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "address",
								"name": "userId",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "date",
								"type": "uint256"
							}
						],
						"internalType": "struct Types.UserHistory[]",
						"name": "dist",
						"type": "tuple[]"
					}
				],
				"internalType": "struct Types.MaterialHistory",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "id",
				"type": "string"
			}
		],
		"name": "getSingleCargoHumanReadable",
		"outputs": [
			{
				"internalType": "string",
				"name": "MaterialType",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "MaterialName",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "SenderName",
				"type": "string"
			},
			{
				"internalType": "string[]",
				"name": "portName",
				"type": "string[]"
			},
			{
				"internalType": "uint256[]",
				"name": "portTime",
				"type": "uint256[]"
			},
			{
				"internalType": "string[]",
				"name": "shipName",
				"type": "string[]"
			},
			{
				"internalType": "uint256[]",
				"name": "shipTime",
				"type": "uint256[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "id",
				"type": "address"
			}
		],
		"name": "getUserDetails",
		"outputs": [
			{
				"components": [
					{
						"internalType": "enum Types.UserType",
						"name": "uType",
						"type": "uint8"
					},
					{
						"internalType": "address",
						"name": "userId",
						"type": "address"
					},
					{
						"internalType": "string",
						"name": "name",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "email",
						"type": "string"
					},
					{
						"internalType": "string",
						"name": "country",
						"type": "string"
					}
				],
				"internalType": "struct Types.SpecificUser",
				"name": "",
				"type": "tuple"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "geyMyShipDetailsHumanReadable",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			},
			{
				"internalType": "string[]",
				"name": "",
				"type": "string[]"
			},
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			},
			{
				"internalType": "string[]",
				"name": "",
				"type": "string[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
        ],
        
        "networks": {
            "12345": {
                "address": "0x0267c20A120EDD732A6F500dFf328C8eD1797CA5"
            }
        }
    }
];

// Once the page is loaded then it executes the init function to initialize all 
// the elements in the interface (like web3, EthereumExplorer, blockchain status connection, ...).
window.addEventListener('load', async () => await init());

// when the content of the field user-wallet-address changes then it is going to update
// the span element "user-wallet"
document.getElementById('user-wallet-address').addEventListener('input', e => {
    UI.setInnerHtml('user-wallet', e.target.value);
});

/**
 * Initialize the objects and UI for interacting with the blockchain.
 */
async function init() {
    // init the EthereumExplorer instance
    window.ethExp = new EthereumExplorer;

    // setting the messages in the UI to show the attempt to connect with the blockchain
    UI.setInnerHtml('status', 'connecting...');
    UI.console('connecting...');

    try {
        // initializing the Web3.js object
        await window.ethExp.bootWeb3();

        // if the Web3.js object is initialized then it means that we are connected
        UI.setInnerHtml('status', 'connected');
        UI.console('connected');

        // showing on the UI some general information
        UI.setInnerHtml('user-wallet', await window.ethExp.getUserAccount());
        UI.setInnerHtml('network-id', await window.ethExp.getNetworkId());
        //UI.setInnerHtml('gas-limit', await window.ethExp.getGasLimit());
        //UI.setInnerHtml('gas-price', await window.ethExp.getGasPrice());

        // loading the ABI of the smart contracts into the EthereumExplorer object.
        await bootContracts(contractDetailsJson);

        initUi();
    } catch (error) {
        UI.setInnerHtml('status', 'error');
        UI.consoleError('ERROR: ' + error.message);
        throw error;
    }
}

/**
 * Load the smart contract details (ABI and contract's address) on the EthereumExplorer object.
 * The object contractDetails is created on runtime and it has the following structure:
 * [
 *      {
 *          contractName: contract1,
 *          abi: { ... },
 *          networks: 0x...,
 *      }, {
 *          contractName: contract2,
 *          abi: { ... },
 *          networks: 0x...,
 *      }
 * ]
 * Please check out the function AbiLoader@getAbiFromFolder
 *
 * @param   {Array}  contractDetails  The details of the contract (like ABI, contract name and network).
 */
async function bootContracts(contractDetails) {
    // getting the current network ID of the blockchain we are connected to
    const netId = await window.ethExp.getNetworkId();

    // iterating through all the smart contracts
    for (let key in contractDetails) {
        // if the contract does not have a network ID on the current blockchain network we are connected to
        // then it means the contracts have not been published on the current blockchain network.
        if (! contractDetails[key].networks[netId]) {
            UI.consoleError(`ERROR: the network ID ${netId} does not exist for the contract ${contractDetails[key].contractName}. Probably you have to change network.`);
            continue;
        }

        // loading the contract into the the EthereumExplorer object
        await window.ethExp.loadContact(
            contractDetails[key].networks[netId].address, 
            contractDetails[key].abi, 
            contractDetails[key].contractName
        );
    }
}

/**
 * Initialize the UI: messages and interface for each smart contract loaded into
 * the EthereumExplorer object.
 */
function initUi() {
    // the EthereumExplorer global object must be initialized
    if (! window.ethExp) throw 'The Blockchain explorer is not initialized!';

    // generating the HTML code: adding a tab element for each smart contract
    let i = 0;
    for (let key in window.ethExp.contractDetails) {
        addContractToDashboard(window.ethExp.contractDetails[key], i++ == 0);
    }

    // Each smart contract's  tab in the UI has a select with the list of all the smart contract
    // functions (the box named "Select a function"). The for below appends an event to each entries
    // of the select to show the smart contract's function form the user selected
    for (let key in window.ethExp.contractDetails) {
        document.getElementById('smFunctions-' + key).addEventListener('change', e => {
            UI.hideElementsByClass('sm-fnc-panel-' + key); // hiding all the other smart contract's function form
            UI.showElement(e.target.value); // showing only the smart contract's form the user selected
        });
    }

    // initializing the blockchain events to show on the console
    initSmartContractEvents();
    document.getElementById('loadBlockchainEvents').addEventListener('click', initSmartContractEvents);
    
    // initializing the bootstrap CSS elements on the tab navigator (otherwise when you click on a
    // tab element it wont work).
    UI.initBootstrapTabs();

    // showing the dashboard main element only when everything has been initialized
    UI.showElement('dashboard');
}

/**
 * Get the current user wallet address: it can be inserted manually in the field
 * "user-wallet-address" or taken automatically.
 *
 * @return  {string}    The user's wallet.
 */
async function getUserAddress() {
    var userAddress = document.getElementById('user-wallet-address').value;

    if (userAddress && userAddress.length) return userAddress;

    return  await window.ethExp.getUserAccount();
}

/**
 * Get the wallet's private key inserted in the field "user-private-key".
 *
 * @return  {string}
 */
/*function getUserPrivateKey() {
    var userPrivateKey = document.getElementById('user-private-key').value;

    if (userPrivateKey && userPrivateKey.length) return userPrivateKey;

    return null;
}*/

/**
 * Showing all the blockchain events into the console.
 */
async function initSmartContractEvents() {
    var criteria = document.getElementById("events-load-criteria").value;
    var from = document.getElementById("events-load-from").value;
    
    UI.setInnerHtml('events-console', '');

    if (typeof from == 'string' && !from.length) {
        document.getElementById("events-load-from").value = from = 50;

        const options = Array.from(document.getElementById("events-load-criteria").options);
        const optionToSelect = options.find(item => item.text === 'load-from-the-last-blocks');
        if (optionToSelect) optionToSelect.selected = true;
    } else if (! /^\d+$/.test(from)) {
        UI.eventsConsoleError('Number not valid!');
        return;
    }

    if (criteria == 'load-from-the-last-blocks') {
        await loadEventsFromLatestBlocks(from);
        return;
    }
    
    if (from < 0) from = 0;
    loadEventsFromSmartContracts(from);
}

/**
 * It loads the events from the latest X blocks (passed as parameter).
 *
 * @param   {integer}  fromBlockNumber      The number of latest blocks to load the events.
 */
async function loadEventsFromLatestBlocks(fromBlockNumber) {
    var blockNumber = await window.ethExp.getBlockNumber();
    var from = blockNumber - fromBlockNumber;

    if (from < 0) {
        UI.eventsConsole(`The blockchain has ${blockNumber} blocks. Loading the events from the block 0.`);
        from = 0;
    } else {
        UI.eventsConsole('Loading the events from the latest ' + fromBlockNumber + ' blocks');
    }

    loadEventsFromSmartContracts(from);
}

/**
 * Load the events of all smart contracts from the given block number.
 *
 * @param   {integer}  fromBlockNumber      The starting block number the events has to be loaded.
 */
function loadEventsFromSmartContracts(fromBlockNumber) {
    for (let contractName in window.ethExp.contractDetails) {
        window.ethExp.contract(contractName).events.allEvents({
            fromBlock: fromBlockNumber
        }, function(error, event) { 
            //UI.eventsConsoleError(event);
        })
        .on("connected", function(subscriptionId){
            UI.eventsConsoleSuccess({ on:'connected', subscriptionId });
        })
        .on('data', function(event){
            //UI.eventsConsole({ on:'data', event }); // same results as the optional callback above
            processEvent(event)
            console.log(event.blockNumber);
            
            
        })
        .on('changed', function(event){
            UI.eventsConsole({ on:'changed', event });
        })
        .on('error', function(error, receipt) {
            // If the transaction was rejected by the network with a receipt, the second parameter will be the receipt.
            if (receipt) {
                UI.eventsConsoleError({ on:'error', receipt, error });
            } else {
                UI.eventsConsoleError({ on:'error', error});
            }
        });
    }
}

async function processEvent(event) {
    var block = window.ethExp.web3.eth.getBlock(event.blockNumber);
    var ts = await block;
    
    console.log(ts.timestamp)
    
    dt = new Date(ts.timestamp*1000)
    if(event.event == "MaterialTransfer")
    {
         UI.eventsConsole("Material with the id '"+event.returnValues.id+"', named '"+event.returnValues.name+"' was transfered to user: '"+event.returnValues.newOwnName+"'. The event was emitted at: "+dt.toISOString());
    } else if (event.event == "NewMaterial")
    {
        UI.eventsConsole("Material with the id '"+event.returnValues.id+"', named '"+event.returnValues.name+"' was added to the system by the supplier: '"+event.returnValues.supplierName+"'. The event was emitted at: "+dt.toISOString());
    } else if (event.event == "UserCreated")
    {
        var type = ''
        switch (event.returnValues.userType) {
            case '0':
                type='Supplier';
                break;
           case '1':
                type='Port Authority';
                break;
           case '2':
                type='Ship';
                break;          
           case '3':
                type='Distributer';
                break;
           case '4':
                type='Administrator';
                break;     
        }
        UI.eventsConsole("User named '"+event.returnValues.name+"', with e-mail address: '"+event.returnValues.email+"' of type: '"+type+"' was added to the system. The event was emitted at: "+dt.toISOString());
    } else if (event.event == "UserRemoved")
    {
        var type = ''
        switch (event.returnValues.userType) {
            case '0':
                type='Supplier';
                break;
           case '1':
                type='Port Authority';
                break;
           case '2':
                type='Ship';
                break;          
           case '3':
                type='Distributer';
                break;
           case '4':
                type='Administrator';
                break;     
        }
        UI.eventsConsole("User named '"+event.returnValues.name+"', with e-mail address: '"+event.returnValues.email+"' of type: '"+type+"' was removed from the system. The event was emitted at: "+dt.toISOString());
    } else if (event.event == "ShipStatusChanged")
    {
        var type = ''
        switch (event.returnValues.status) {
            case '0':
                type='Arrival';
                break;
           case '1':
                type='Arrival/Anchored';
                break;
           case '2':
                type='Berthed';
                break;          
           case '3':
                type='Anchored';
                break;
           case '4':
                type='Departure';
                break;     
           case '5':
                type='Bunkering';
                break;
          case '6':
                type='Underwater cleaning';
                break;    
                
        }
        UI.eventsConsole("Ship '"+event.returnValues.shipName+"' change its location to: Port '"+event.returnValues.portName+"' with the status: '"+type+"'. The event was emitted at: "+dt.toISOString());
    }
    
    
}


/**
 * Handle the call to a smart contract function submitted in a form.
 * @TODO refactor this function.
 * 
 * @param   {Object}  e     The event object when the form is submitted.
 */
async function handleSmartContractCall(e) { 
    e.preventDefault();

    // getting the data coming from the submitted form
    const data = new FormData(e.target);
    var options = {};
    const contractName = data.get('contract-name'); // name of the smart contract
    const scFnc = data.get('function-name');  // name of the smart contract's function

    var params = []; // is going to store all the parameters required from the smart contract's function

    for (const [name, val] of data) {
        if (! name.includes('input[')) continue;
        params.push(val);
    }

    // adding the eventual tx_value for payable smart contract methods
    if (data.has('tx_value')) {
        var val = data.get('tx_value');
        if (val && val.length && !isNaN(val)) options.value = parseInt(val);
    }

    try {
        UI.consoleHtml(`Calling the smart contract function: <b>${scFnc}</b>`);

        var userAddress = await getUserAddress(); // getting the user address (from the field or from the default user wallet)
        //var userPrivateKey = getUserPrivateKey(); // getting the eventual private key from the input field of the UI
        var userPrivateKey = '';
        // calling a function that is PURE or VIEW
        if (window.ethExp.methodIsViewOrPure(scFnc, contractName)) {
            // NOTE: msg.sender is 0x0 on the VIEW methods. The client must set
            // {from: userAddress} when calling the smart contract
            var res = await window.ethExp.call(scFnc, params, contractName, {from: userAddress});
            //UI.consoleSuccess(res);
            UI.show_details(scFnc, res, {});

            
        } 
        // calling a function that is NON PAYABLE
        else if (window.ethExp.methodIsNonPayable(scFnc, contractName)) {
            (await window.ethExp.sendTxToSmartContract(userAddress, userPrivateKey, scFnc, params, options, contractName))
                .on('transactionHash', transactionHash => UI.consoleSuccess({ transactionHash }))
                .on('receipt', receipt => UI.consoleSuccess({ receipt }))
                .on('error', error => {
                    UI.consoleError('Error occurred: ' + error.message);
                    console.log(error);
                });
        } 
        // calling a function that is PAYABLE
        else if (window.ethExp.methodIsPayable(scFnc, contractName)) {
            (await window.ethExp.sendTxToSmartContract(userAddress, userPrivateKey, scFnc, params, options, contractName))
                .on('transactionHash', transactionHash => UI.consoleSuccess({ transactionHash }))
                .on('receipt', receipt => UI.consoleSuccess({ receipt }))
                .on('error', error => {
                    UI.consoleError('Error occurred: ' + error.message);
                    console.log(error);
                });
        }
        // Throwing an error in case of the state mutability is not fund
        else {
            throw new Error('The stateMutability of the smart contract function ' + scFnc + ' is not defined.');
        }
    } catch (error) {
        if (error.message.includes('invalid arrayify value')) {
            var message = 'probably you input a wrong type as parameter.' + '<br>ERROR DETAIL:' + error.message;
        } else {
            var message = error.message;
        }

        UI.consoleError('Error Occurred: ' + message);
        console.log(error);
    }
}

/**
 * Add dynamically the HTML for showing the tabs of each smart contract:
 * - In the HTML element "contracts-tab-nav" it adds a tab with the name of the smart contract.
 * - In the HTML element "contracts-tab-content" it adds the content of the tab (which is a dynamic
 *   select with the list of the smart contract's functions).
 *
 * @param   {Object}   contract      The smart contract details and ABI.
 * @param   {boolean}  active        Whether the tab should be active or not.
 */
function addContractToDashboard(contract, active=false) {
    const cName = contract.contractName;

    // adding a tab HTML element with the name of the smart contract
    document.getElementById('contracts-tab-nav').innerHTML += `
        <li class="nav-item">
            <a class="nav-link ${active ? 'active' : ''} smart-contract-tab" data-bs-toggle="tab" href="#contract-tab-${cName}">${cName}</a>
        </li>
    `;

    // creating the content of the tab: the content is split in 2 columns:
    //  - In the left column there is a select with the list of the function related to the selected smart contract.
    //  - In the right column (smContractPanels-${cName}) it will appear the form of the selected smart contract function.
    document.getElementById('contracts-tab-content').innerHTML += `
        <div class="tab-pane p-4 fade ${active ? 'active show' : ''} smart-contract-content" id="contract-tab-${cName}">
            <h3 class="pb-3"><b>ABMarSupply</b></h3>
            <div class="row">
                <div class="col-md-4">
                    <div class="card">
                        <div class="card-header">Select a function</div>
                        <div class="card-body p-0">
                            <select name="smFunctions-${cName}" id="smFunctions-${cName}" size="10" class="form-select"></select>
                        </div>
                    </div>
                </div>

                <div class="col-md-8" id="smContractPanels-${cName}"></div>
            </div>
        </div>
    `;

    // add dynamically a form for each smart contract function found in the contract's ABI
    for (let abiItem of contract.abi) {
        if (abiItem.type == 'function') addFncToDashboard(cName, abiItem);
    }
}

/**
 * Add dynamically a form into the tab content (please check the function "addContractToDashboard") 
 * to call a specific smart contract function.
 *
 * @param   {string}  contractName      The name of the smart contract.
 * @param   {Object}  abiItem           Smart contract's ABI.
 */
 
function processFName(name) {

    switch(name) {
    case "addCargo":
        return "Add new cargo to the system";
    case "addNewUser":
        return "Add new user to the system";
    case "changeShipPortStatus":
        return "Change ship port status";
    case "trasferCargo":
        return "Transfer cargo from user to user";
    case "getAllCargo":
        return "List every cargo in the system";
    case "getMyCargo":
        return "List every cargo belonging to current user";
    case "getMyDetails":
        return "Return the data related to current user";
    case "getShipDetails":
        return "Return the data related to specific ship";
    case "getShipDetailsHumanReadable":
        return "Return the port history of the ship";
    case "getSingleCargo":
        return "Return the data related to specific cargo";
    case "getSingleCargoHumanReadable":
        return "Return the history of the specific cargo";
    case "getUserDetails":
        return "Return the data related to specific user";
    case "geyMyShipDetailsHumanReadable":
        return "Return the port history of the ship that is the current user";
    }    
    return name;


}
function addFncToDashboard(contractName, abiItem) {
    var formId = 'sm_' + contractName + '_' + abiItem.name;

    // adding an option element into the select created in "addContractToDashboard"
    // The option element has as value the Form ID and as label the function name
    var opt = document.createElement('option');
    opt.value = formId; // value of the select's option
//    opt.innerHTML = abiItem.name; // label of the select's option
    opt.innerHTML = processFName(abiItem.name); // label of the select's option
    // adding the option to the select
    document.getElementById('smFunctions-' + contractName).appendChild(opt);

    const div = document.createElement('div');

    // creating the HTML for showing the form with all the fields required to interact with the 
    // specific smart contract function (abiItem.name)
    var html = `
        <form method="POST" id="${formId}" class="sm-fnc-panel-${contractName}" style="display:none">
            <input type="hidden" name="contract-name" value="${contractName}" />
            <input type="hidden" name="function-name" value="${abiItem.name}" />
            <div class="card mb-3">
                <div class="card-header">
                    <b>${abiItem.name}</b>
                </div>
                <div class="card-body">
                    <div class="row">`;
                        var i = 0;

                        // adding an input field for each input of the smart contract function found in the ABI specification
                        for (let input of abiItem.inputs) {
                            html += `
                                <div class="mb-3">
                                    <label for="formFileSm" class="form-label">${input.name} / ${input.type}</label>
                                    <input type="text" name="input[${i++}]" class="form-control form-control-sm">
                                </div>
                            `;
                        }

                        // if the smart contract's function is payable then it adds an extra field to send funds to the smart contract.
                        if (window.ethExp.methodIsPayable(abiItem.name, contractName) || window.ethExp.methodIsNonPayable(abiItem.name, contractName)) {
                            html += `
                                <hr>
                                <div class="mb-3">
                                    <label for="formFileSm" class="form-label">Value</label>
                                    <input type="text" name="tx_value" class="form-control form-control-sm">
                                </div>
                            `;
                        }

                        html += `
                    </div>
                </div>
                <div class="card-footer">
                    <button type="submit" class="btn btn-danger btn-sm">Execute</button>
                </div>
            </div>
        </form>
    `;

    // adding the HTML of the form just created to the smart contract tab (right column)
    div.insertAdjacentHTML('beforeend', html);
    document.getElementById('smContractPanels-' + contractName).appendChild(div);

    // appending the event on submit on the form just created
    // @TODO added the setTimeout because the event was not appended to the formId element. Find a nicer way.
    setTimeout(() => document.getElementById(formId).addEventListener('submit', handleSmartContractCall), 200);
}

/* ************************************************************************** */
/* ***********************       UTILITY CLASSES       ********************** */
/* ************************************************************************** */

/**
 * Utility class for manipulating the interface.
 */
class UI {

    /**
     * Set the HTML of the element ID with the given content. 
     *
     * @param   {string}         elementId     The ID of the HTML element.
     * @param   {string|Object}  content       The content should be set to the element.
     */
    static setInnerHtml(elementId, content) {
        if (typeof content == 'object') content = JSON.stringify(content, null, '    ');

        document.getElementById(elementId).innerHTML = content;
    }

    /**
     * Append the given content to the given HTML element ID.
     *
     * @param   {string}         elementId     The ID of the HTML element.
     * @param   {string|Object}  content       The content should be set to the element.
     */
    static appendInnerHtml(elementId, content) {
        if (typeof content == 'object') content = JSON.stringify(content, null, '    ');

        document.getElementById(elementId).innerHTML += '<br>' + content;
    }

    /**
     * Show an element by setting the "display" CSS property to "block".
     *
     * @param   {string}    elementId     The ID of the HTML element.
     * @param   {[type]}    displayProp   The property to set to the "display" CSS attribute (default "block").
     */
    static showElement(elementId, displayProp='block') {
        document.getElementById(elementId).style.display = displayProp;
    }

    /**
     * Hide an element by setting the "display" CSS property to "none".
     *
     * @param   {string}    elementId     The ID of the HTML element.
     * @param   {string}    displayProp   The property to set to the "display" CSS attribute (default "none").
     */
    static hideElement(elemId, displayProp='none') {
        document.getElementById(elemId).style.display = displayProp;
    }

    /**
     * Hide all elements having the given CSS class as parameter.
     *
     * @param   {[type]}  className    CSS class of the elements to hide.
     * @param   {[type]}  displayProp  The property to set to the "display" CSS attribute (default "none").
     */
    static hideElementsByClass(className, displayProp='none') {
        for (let el of document.getElementsByClassName(className)) {
            el.style.display = displayProp;
        }
    }

    /**
     * Show an error on the UI's console styled as error.
     * This function is used to show blockchain events.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static eventsConsoleError(message) {
        UI.eventsConsole(message, { isError: true });
    }

    /**
     * Show an HTML message to the UI's console.
     * This function is used to show blockchain events.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static eventsConsoleHtml(message) {
        UI.eventsConsole(message, { htmlSanitize: false });
    }

    /**
     * Show a success message on the UI's console styled as success.
     * This function is used to show blockchain events.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static eventsConsoleSuccess(message) {
        UI.eventsConsole(message, { isSuccess: true });
    }

    /**
     * Display a blockchain event to the UI's console.
     * This function is a wrapper around the "console" function.
     *
     * @param   {string|Object}     message   The message to show.
     * @param   {Object}            options   Eventual options for displaying the message (like isError, isSuccess, snitize HTML, ...).
     */
    static eventsConsole(message, options={}) {
        UI.console(message, options, 'events-console');
    }

    /**
     * Show an error on the UI's console.
     * This function is a wrapper around the "console" function.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static consoleError(message) {
        UI.console(message, { isError: true });
    }

    /**
     * Show a message in the UI's console without sanitizing the given message.
     * This function is a wrapper around the "console" function.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static consoleHtml(message) {
        UI.console(message, { htmlSanitize: false });
    }

    /**
     * Show a success message in the UI's console.
     * This function is a wrapper around the "console" function.
     *
     * @param   {string|Object}     message   The message to show.
     */
    static consoleSuccess(message) {
        UI.console(message, { isSuccess: true });
        
    }

    /**
     * Append a message into the UI console HTML element.
     *
     * @param   {string|Object}     message   The message to show.
     * @param   {Object}            options   Eventual options for displaying the message (like isError, isSuccess, snitize HTML, ...).
     * @param   {string}            elemId    The ID of the HTML element.
     */
    static console(message, options={}, elemId='console') {
        var consoleElem = document.getElementById(elemId);

        // transforming the message into JSON string if it is an object
        if (typeof message == 'object') message = JSON.stringify(message, null, '    ');

        // appending the timestamp in front of the message
        message = (new Date().toISOString()) + ': ' + message;

        // appending eventual classes to style the message
        var classes = '';
        if (options.isError) classes = 'text-danger';
        else if (options.isSuccess) classes = 'text-success';

        // sanitizing the message (default = true)
        if (typeof options.htmlSanitize == 'undefined') options.htmlSanitize = true;
        if (options.htmlSanitize) {
            message = message.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }

        // appending the message HTML into the console element
        consoleElem.innerHTML += `<p class="m-0 pt-0 pb-2 ${classes}">${message}</p>`;

        // scrolling the console to the bottom to show the last message
        consoleElem.scrollTop = consoleElem.scrollHeight;
    }

    static create_table(content, headers){
        var table = document.createElement('table');
        table.setAttribute('class', 'table table-striped text-wrap');
        table.setAttribute('style', 'max-height: 500px;');
        var header = table.createTHead();
        var body = table.createTBody();
        var row = header.insertRow();

        for (var i=0; i<headers.length; i++){
            var cell = row.insertCell();
            cell.innerHTML = "<strong>" +headers[i]+ "</strong>";
        }
        for (var i = 0; i < content.length; i++){
                var obj = content[i];

                //console.log(obj)
                row = body.insertRow()
                for (var j = 0; j < headers.length; j++){
                    //console.log(obj[key])
                    var cell = row.insertCell()
                    cell.innerHTML = obj[j]
                }
        }
        //tableElem.appendChild(table);
        return table;


    }

    static show_details(type, content, options={}, elementId = 'smart-contract-details')
    {
        var tableElem = document.getElementById(elementId);
        var classes = '';
        //content = (new Date().toISOString()) + ': ' + content;
        if (type=='getAllCargo' || type=='getMyCargo'){
            tableElem.replaceChildren();


            var matr = ["AluminaHydrat",
            "Wheat",
            "SteelCoils",
            "FertilizerInBags",
            "Urea",
            "NPK",
            "TSP",
            "CementClinker",
            "SteelHotRolledCoils",
            "Barley",
            "Lentils"];
            var data = [];
            for (var i = 0; i< content.length; i++)
            {
                var row = [];
                row.push(content[i][0], content[i][1], content[i][2], content[i][3], matr[parseInt(content[i][4])], content[i][5], content[i][6] );
                data.push(row);
            }

            var headers = ["ID", "Name", "Supplier Name", "Supplier", "Material Type", "Quantity", "Unit"];
            var table = UI.create_table(data,headers);
            tableElem.appendChild(table);

        }
        else if(type=='getMyDetails' || type == 'getUserDetails')
        {
            tableElem.replaceChildren();
            var span = document.createElement('span')
            span.innerHTML = "<strong>User Type:</strong> "+content['uType']+"<br/>"
            + "<strong>User ID:</strong> "+content['userId']+"<br/>"
            + "<strong>Name:</strong> "+content['name']+"<br/>"
            + "<strong>Email:</strong> "+content['email']+"<br/>"
            + "<strong>Country:</strong> "+content['country']+"<br/>"
            tableElem.appendChild(span);
        }
        else if(type=='getShipDetails')
        {
            tableElem.replaceChildren();
            var span = document.createElement('span')
            span.innerHTML = "<strong>User Type:</strong> "+content[0]['uType']+"<br/>"
            + "<strong>User ID:</strong> "+content[0]['userId']+"<br/>"
            + "<strong>Name:</strong> "+content[0]['name']+"<br/>"
            + "<strong>Email:</strong> "+content[0]['email']+"<br/>"
            + "<strong>Country:</strong> "+content[0]['country']+"<br/>"
            tableElem.appendChild(span);

        }
        else if(type=='getSingleCargo')
        {
            var matr = ["AluminaHydrat",
            "Wheat",
            "SteelCoils",
            "FertilizerInBags",
            "Urea",
            "NPK",
            "TSP",
            "CementClinker",
            "SteelHotRolledCoils",
            "Barley",
            "Lentils"];
            tableElem.replaceChildren();
            var span = document.createElement('span')
            span.innerHTML = "<strong>Cargo ID:</strong> "+content[0]['id']+"<br/>"
            + "<strong>Material Type: </strong> "+matr[parseInt(content[0]['mType'])]+"<br/>"
            + "<strong>Name:</strong> "+content[0]['name']+"<br/>"
            + "<strong>Quantity:</strong> "+content[0]['qty']+"<br/>"
            + "<strong>Supplier:</strong> "+content[0]['supplierName']+"<br/>"
            + "<strong>Unit:</strong> "+content[0]['unit']+"<br/>"
            tableElem.appendChild(span);

        }
        else if(type=='getShipDetailsHumanReadable')
        {
            tableElem.replaceChildren();
            var data_trans = [];
            var portNames = content['portName'];
            var portStatus = content['portStatus'];
            var portTime = content['portTime'];

            for (var i=0; i<portNames.length; i++)
            {
                var row = [];
                row.push(portNames[i], new Date(parseInt(portTime[i])*1000), portStatus[i])
                data_trans.push(row)

            }
            var table = UI.create_table(data_trans,['Port', 'Time', 'Status'])
            tableElem.appendChild(table);

        }
        else if(type=='geyMyShipDetailsHumanReadable')
        {
            tableElem.replaceChildren();
            var data_trans = [];
            var portNames = content[1];
            var portStatus = content[3];
            var portTime = content[2];

            for (var i=0; i<portNames.length; i++)
            {
                var row = [];
                row.push(portNames[i], new Date(parseInt(portTime[i])*1000), portStatus[i])
                data_trans.push(row)

            }
            var table = UI.create_table(data_trans,['Port', 'Time', 'Status'])
            tableElem.appendChild(table);

        }
        else if(type=='getSingleCargoHumanReadable')
        {
            tableElem.replaceChildren();
            var span = document.createElement('span')
            span.innerHTML = "<strong>Material Type:</strong> "+content['MaterialType']+"<br/>"
            + "<strong>Material:</strong> "+content['MaterialName']+"<br/>"
            + "<strong>Sender:</strong> "+content['SenderName']+"<br/><br/><br/>";
            tableElem.appendChild(span);
            var data = []
            for (var i=0; i<content['portName'].length; i++)
            {
                var row = [];
                row.push(content['portName'][i], new Date(parseInt(content['portTime'][i])*1000), content['shipName'][i], new Date(parseInt(content['shipTime'][i])*1000));
                data.push(row)

            }
            var headers = ["Port", "Port Time", "Ship", "Ship Time"];
            var table = UI.create_table(data,headers);
            tableElem.appendChild(table);
            
            

        }
        else{
            tableElem.replaceChildren();
            console.log(content)

        }
        

        //tableElem.innerHTML += `<p class="m-0 pt-0 pb-2 ${classes}">${content}</p>`;
    }

    /**
     * Initialize the events on the CSS bootstrap tab elements so when the user 
     * clicks on a tab then the related tab content is shown.
     * Note that the page imports only the bootstrap CSS and not the bootstrap JS.
     */
    static initBootstrapTabs() {
        document.querySelectorAll('.nav-tabs a.nav-link').forEach(el => {
            el.addEventListener('click', event => {
                let navTabs = event.target.parentNode.parentNode;
                
                navTabs.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
                event.target.classList.add('active');

                Array.from(navTabs.nextElementSibling.children).forEach(el => {
                    el.classList.remove('active');
                    el.classList.remove('show');
                });

                let target = document.querySelector(event.target.getAttribute('href'));
                if (target) {
                    target.classList.add('active');
                    target.classList.add('show');
                }
            });
        });
    }
}

/**
 * Utility class to make easier the interaction with the Ethereum blockchain.
 */
class EthereumExplorer {
    
    /**
     * Constructor: initialize the default values of the class attributes.
     */
    constructor() {
        this.web3 = null;
        this.contracts = {};
        this.contractDetails = {};
        this.defaultOptions = {
            gasLimit: null,
            gasPrice: null,
        };
        this.userAccount = null;
        this.callbacks = {};
    }

    /**
     * Initialize Web3.js
     */
    async bootWeb3() {
     
        this.web3 = new Web3("ws://localhost:8546");
    }

    /**
     * Load into the EthereumExplorer object all the details of a smart contract.
     * The details needed are the compiled details of the smart contract (like ABI).
     *
     * @param   {Object}  contractJson  The details of the contract to load.
     * @param   {string}  contractName  The name of the contract.
     */
    async loadContractFromJson(contractJson, contractName='default') {
        var netId = await this.getNetworkId();
        
        if (! contractJson.networks[netId]) {
            throw 'The network ID does not exist in the JSON of the contract. Probably you have to change network. Current network: ' + netId;
        }

        this.loadContact(contractJson.networks[netId].address, contractJson.abi, contractName);
    }

    /**
     * Store the contract details in the class "contractDetails" attribute and
     * then store the contract object from web3/eth into the attribute "contracts"
     * for an easy picking of the contract object.
     *
     * @param   {string}  contractAddress  Address of the contract.
     * @param   {Object}  contractAbi      The ABI of the contract.
     * @param   {string}  contractName     The name of the contract, useful if you deal with more than one smart contract.
     */
    loadContact(contractAddress, contractAbi, contractName='default') {
        this.contractDetails[contractName] = {};
        this.contractDetails[contractName].address = contractAddress;
        this.contractDetails[contractName].abi = contractAbi;
        this.contractDetails[contractName].contractName = contractName;

        this.contracts[contractName] = new this.web3.eth.Contract(contractAbi, contractAddress);
    }

    /**
     * Return the web/eth contract instance loaded in the function "loadContact".
     *
     * @param   {string}  contractName      The name of the contract.
     */
    contract(contractName='default') {
        return this.contracts[contractName];
    }

    /**
     * Return the contract details loaded in the function "loadContact".
     *
     * @param   {string}  contractName      The name of the contract.
     */
    contractDetail(contractName='default') {
        return this.contractDetails[contractName];
    }

    /**
     * Call a smart contract function.
     *
     * @param   {string}  method        The name of the smart contract function to call.
     * @param   {mixed}   param         The parameters to pass to the smart contract function we are calling.
     * @param   {string}  contractName  The name of the smart contract.
     * @param   {Object}  options       Extra options for calling the smart contract method (please reference to the Web3.js documentation).
     */
    async call(method, param, contractName='default', options={}) {
        if (param === null) {
            return this.contracts[contractName].methods[method]().call(options);
        }
        
        if (typeof param == 'object') {
            return this.contracts[contractName].methods[method](...param).call(options);
        }

        return this.contracts[contractName].methods[method](param).call(options);
    }

    /**
     * Get the network ID of the blockchain we are connected to.
     *
     * @return  {Integer}    The ID of the blockchain network.
     */
    async getNetworkId() {
        return await this.web3.eth.net.getId(); 
    }

    /**
     * Check if a smart contract method is pure, view, payable, non payable, ...
     *
     * @param   {string}  type          The type of the method to check (pure, view, payable, ...).
     * @param   {string}  method        The name of the method to call.
     * @param   {string}  contractName  The name of the smart contract.
     * @return  {boolean|null}
     */
    methodTypeIs(type, method, contractName='default') {
        if (this.contractDetail(contractName) && this.contractDetail(contractName).abi) {
            const fnc = this.contractDetail(contractName).abi.filter(item => item.name == method);
            if (! fnc.length) return null;

            return (fnc[0].stateMutability && fnc[0].stateMutability == type);
        }

        return null;
    }

    /**
     * Check if the smart contract method is pure.
     *
     * @param   {string}  method        The name of the method to call.
     * @param   {string}  method        The name of the method to call.
     * @return  {boolean|null}
     */
    methodIsViewOrPure(method, contractName='default') {
        return (this.methodTypeIs('view', method, contractName) || this.methodTypeIs('pure', method, contractName));
    }

    /**
     * Check if the smart contract method is payable.
     *
     * @param   {string}  method        The name of the method to call.
     * @param   {string}  method        The name of the method to call.
     * @return  {boolean|null}
     */
    methodIsPayable(method, contractName='default') {
        return this.methodTypeIs('payable', method, contractName);
    }

    /**
     * Check if the smart contract method is non payable.
     *
     * @param   {string}  method        The name of the method to call.
     * @param   {string}  method        The name of the method to call.
     * @return  {boolean|null}
     */
    methodIsNonPayable(method, contractName='default') {
        return this.methodTypeIs('nonpayable', method, contractName);
    }

    /**
     * Submit a transaction to the smart contract.
     *
     * @param   {string}            fromAddress     The address of the user's wallet.
     * @param   {string|null}       fromPrivateKey  The private key of the user's wallet/
     * @param   {string}            contractFnc     The name of the function of the smart contract we are calling.
     * @param   {Array}             contractData    Extra data to sent along with the smart contract call.
     * @param   {[type]}            options         Extra option needed for calling the smart contract (for example when the method is payable then you might need to send funds to the smart contract).
     * @param   {[type]}            contractName    The name of the smart contract.
     *
     * @return  {Object}            Return the transaction promise.
     */
    async sendTxToSmartContract(fromAddress, fromPrivateKey, contractFnc, contractData=[], options={}, contractName='default') {
        // checking if the contract has been loaded
        if (! this.contractDetail(contractName)) {
            throw 'Contract address not found!';
        }

        // getting the transaction raw data
        var txData = await this.getTransactionData(
            fromAddress,
            this.contractDetail(contractName).address,
            options
        );

        // checking if there is a fund to send to the smart contract
        if (options.value) txData.value = options.value;

        // if the private key is given then we must sign the transaction with that private key
        if (/*fromPrivateKey*/ true) {
            const data = this.contract(contractName).methods[contractFnc](...contractData).encodeABI();
            if (data) txData.data = data;

            // signing the transaction with the given private key
            //TODO: Probaj da zamenis privatni kljuc sa sifrom
            //const signedTx = await this.web3.eth.accounts.signTransaction(txData, fromPrivateKey);
            const signedTx = await this.web3.eth.personal.signTransaction(txData, 'f');
            console.log(signedTx.raw);
            // DOCS: https://web3js.readthedocs.io/en/v1.7.3/web3-eth.html?highlight=sendSignedTransaction#id90
            //this.web3.eth.sendSignedTransaction(signedTx.rawTransaction)
            this.web3.eth.sendSignedTransaction(signedTx.raw)
                .on('transactionHash', transactionHash => this.emit('transactionHash', transactionHash))
                .on('receipt', receipt => this.emit('receipt', receipt))
                .on('error', error => this.emit('error', error));
            
            return Promise.resolve(this);
        }

        // if the private key is not given then teh signature will be handled via Metamask (or similar)
        this.contract(contractName).methods[contractFnc](...contractData).send(txData)
            .on('transactionHash', transactionHash => this.emit('transactionHash', transactionHash))
            .on('receipt', receipt => this.emit('receipt', receipt))
            .on('error', error => this.emit('error', error));

        return Promise.resolve(this);
    }

    /**
     * Get the basic transaction data.
     *
     * @param   {string}  from     The users's wallet address.
     * @param   {string}  to       The destination address.
     * @param   {Object}  options  The eventual default options.
     *
     * @return  {Object}           The transaction data.
     */
    async getTransactionData(from, to, options={}) {
        return { from, to, 
            nonce: options.nonce || await this.web3.eth.getTransactionCount(from, 'pending'),
            gasPrice: options.gasPrice || await this.getGasPrice(false),
            gasLimit: options.gasLimit || await this.getGasLimit(false),
        }
    }

    /**
     * Get the current gas limit.
     *
     * @param   {string}   fromCache    Load the gas limit from the class attribute.
     *
     * @return  {Number|null}           The gas limit.
     */
    async getGasLimit(fromCache=true) {
        if (this.defaultOptions.gasLimit && fromCache) return this.defaultOptions.gasLimit;

        const block = await this.getBlock('latest');

        if (block) {
            this.defaultOptions.gasLimit = 3000000;//block.gasLimit;
            return this.defaultOptions.gasLimit;
        }
        
        return null;
    }

    /**
     * Get the current gas price.
     *
     * @param   {string}   fromCache    Load the gas price from the class attribute.
     *
     * @return  {Number|null}           The gas price.
     */
    async getGasPrice(fromCache=true) {
        if (this.defaultOptions.gasPrice && fromCache) return this.defaultOptions.gasPrice;

        const gasPrice = this.web3.eth.getGasPrice();

        if (gasPrice) {
            this.defaultOptions.gasPrice = gasPrice;
            return gasPrice;
        }
        
        return null;
    }

    /**
     * Get the block details of the given block number.
     *
     * @param   {Integer}  blockNumber  The number of the block to retrieve.
     *
     * @return  {Object}                The details of the block.
     */
    async getBlock(blockNumber) {
        return await this.web3.eth.getBlock(blockNumber);
    }

    /**
     * Return the number of the latest block minded.
     *
     * @return  {Integer}   The number of the latest block.
     */
    async getBlockNumber() {
        return await this.web3.eth.getBlockNumber();
    }

    /**
     * Get the user account from the Metamask (or any other clients manager).
     *
     * @return  {string}  The user's wallet address.
     */
    async getUserAccount() {
        if (this.userAccount) return this.userAccount;

        const accounts = await this.web3.eth.getAccounts();

        this.userAccount = accounts[0];

        return this.userAccount;
    }

    /**
     * Append a callback to a given event.
     *
     * @param   {string}  eventName    The name of the event.
     * @param   {function}  callback   The callback function to attach to the event.
     *
     * @return  {EthereumExplorer}
     */
     on(eventName, callback) {
        if (! this.callbacks[eventName]) {
            this.callbacks[eventName] = callback;
        }

        return this;
    }

    /**
     * Emit an event.
     *
     * @param   {string}  eventName  The name of the event.
     * @param   {mixed}  data        The data to attach to the event
     *
     * @return  {mixed}
     */
    emit(eventName, data) {
        if (this.callbacks[eventName]) {
            return this.callbacks[eventName](data);
        }
    }

}</script>

</body>
</html>
